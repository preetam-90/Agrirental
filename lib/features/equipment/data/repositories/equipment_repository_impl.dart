import 'package:dartz/dartz.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../../core/error/exceptions.dart';
import '../../../../core/error/failures.dart';
import '../../../../core/network/network_info.dart';
import '../../domain/entities/equipment.dart';
import '../../domain/repositories/equipment_repository.dart';
import '../datasources/cloudinary_datasource.dart';
import '../datasources/equipment_remote_datasource.dart';
import '../models/equipment_model.dart';

/// Equipment repository implementation
class EquipmentRepositoryImpl implements EquipmentRepository {
  final EquipmentRemoteDataSource remoteDataSource;
  final CloudinaryDataSource cloudinaryDataSource;
  final NetworkInfo networkInfo;
  final SupabaseClient supabaseClient;
  
  EquipmentRepositoryImpl({
    required this.remoteDataSource,
    required this.cloudinaryDataSource,
    required this.networkInfo,
    required this.supabaseClient,
  });
  
  @override
  Future<Either<Failure, List<Equipment>>> searchNearby({
    required double farmerLatitude,
    required double farmerLongitude,
    EquipmentType? equipmentType,
    double? minRating,
    double? maxHourlyRate,
  }) async {
    // Require network for geospatial search
    final isConnected = await networkInfo.isConnected;
    if (!isConnected) {
      return const Left(NetworkFailure());
    }
    
    try {
      final equipmentModels = await remoteDataSource.searchNearby(
        farmerLatitude: farmerLatitude,
        farmerLongitude: farmerLongitude,
        equipmentType: equipmentType,
        minRating: minRating,
        maxHourlyRate: maxHourlyRate,
      );
      
      final equipment = equipmentModels.map((model) => model.toEntity()).toList();
      return Right(equipment);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    } on NetworkException {
      return const Left(NetworkFailure());
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }
  
  @override
  Future<Either<Failure, Equipment>> getEquipmentById(String id) async {
    final isConnected = await networkInfo.isConnected;
    if (!isConnected) {
      return const Left(NetworkFailure());
    }
    
    try {
      final equipmentModel = await remoteDataSource.getEquipmentById(id);
      return Right(equipmentModel.toEntity());
    } on ServerException catch (e) {
      if (e.statusCode == 404) {
        return Left(ServerFailure('Equipment not found'));
      }
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }
  
  @override
  Future<Either<Failure, List<Equipment>>> getMyEquipment() async {
    final isConnected = await networkInfo.isConnected;
    if (!isConnected) {
      return const Left(NetworkFailure());
    }
    
    try {
      // Get current user ID from Supabase session
      final userId = supabaseClient.auth.currentUser?.id;
      if (userId == null) {
        return const Left(UnauthorizedFailure());
      }
      
      final equipmentModels = await remoteDataSource.getEquipmentByOwnerId(userId);
      final equipment = equipmentModels.map((model) => model.toEntity()).toList();
      return Right(equipment);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }
  
  @override
  Future<Either<Failure, Equipment>> createEquipment({
    required EquipmentType equipmentType,
    required String title,
    String? description,
    String? brand,
    String? model,
    int? manufacturingYear,
    required double latitude,
    required double longitude,
    required double serviceRadiusKm,
    required double hourlyRate,
    double? dailyRate,
    List<String>? imageUrls,
  }) async {
    final isConnected = await networkInfo.isConnected;
    if (!isConnected) {
      return const Left(NetworkFailure());
    }
    
    try {
      // Get current user ID
      final userId = supabaseClient.auth.currentUser?.id;
      if (userId == null) {
        return const Left(UnauthorizedFailure());
      }
      
      // Create equipment model
      final equipmentModel = EquipmentModel(
        id: '', // Will be generated by database
        ownerId: userId,
        ownerName: '', // Will be fetched from join
        equipmentType: equipmentType,
        title: title,
        description: description,
        brand: brand,
        model: model,
        manufacturingYear: manufacturingYear,
        latitude: latitude,
        longitude: longitude,
        serviceRadiusKm: serviceRadiusKm,
        hourlyRate: hourlyRate,
        dailyRate: dailyRate,
        images: imageUrls ?? [],
        primaryImageUrl: imageUrls?.isNotEmpty == true ? imageUrls!.first : null,
        isAvailable: true,
        totalBookings: 0,
        averageRating: 0.0,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      
      final createdEquipment = await remoteDataSource.createEquipment(
        equipmentModel,
        userId,
      );
      
      return Right(createdEquipment.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    } on ValidationException catch (e) {
      return Left(ValidationFailure(e.message));
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }
  
  @override
  Future<Either<Failure, Equipment>> updateEquipment({
    required String id,
    String? title,
    String? description,
    String? brand,
    String? model,
    int? manufacturingYear,
    double? latitude,
    double? longitude,
    double? serviceRadiusKm,
    double? hourlyRate,
    double? dailyRate,
    bool? isAvailable,
    List<String>? imageUrls,
  }) async {
    final isConnected = await networkInfo.isConnected;
    if (!isConnected) {
      return const Left(NetworkFailure());
    }
    
    try {
      // Build updates map with only non-null values
      final Map<String, dynamic> updates = {};
      
      if (title != null) updates['title'] = title;
      if (description != null) updates['description'] = description;
      if (brand != null) updates['brand'] = brand;
      if (model != null) updates['model'] = model;
      if (manufacturingYear != null) updates['manufacturing_year'] = manufacturingYear;
      if (serviceRadiusKm != null) updates['service_radius_km'] = serviceRadiusKm;
      if (hourlyRate != null) updates['hourly_rate'] = hourlyRate;
      if (dailyRate != null) updates['daily_rate'] = dailyRate;
      if (isAvailable != null) updates['is_available'] = isAvailable;
      if (imageUrls != null) {
        updates['images'] = imageUrls;
        if (imageUrls.isNotEmpty) {
          updates['primary_image_url'] = imageUrls.first;
        }
      }
      
      // Update location if both lat/lng provided
      if (latitude != null && longitude != null) {
        updates['location'] = {
          'type': 'Point',
          'coordinates': [longitude, latitude],
        };
      }
      
      final updatedEquipment = await remoteDataSource.updateEquipment(id, updates);
      return Right(updatedEquipment.toEntity());
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }
  
  @override
  Future<Either<Failure, void>> deleteEquipment(String id) async {
    final isConnected = await networkInfo.isConnected;
    if (!isConnected) {
      return const Left(NetworkFailure());
    }
    
    try {
      await remoteDataSource.deleteEquipment(id);
      return const Right(null);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }
  
  @override
  Future<Either<Failure, String>> uploadImage(String imagePath) async {
    final isConnected = await networkInfo.isConnected;
    if (!isConnected) {
      return const Left(NetworkFailure());
    }
    
    try {
      final imageUrl = await cloudinaryDataSource.uploadImage(imagePath);
      return Right(imageUrl);
    } on ServerException catch (e) {
      return Left(ServerFailure(e.message));
    } on ValidationException catch (e) {
      return Left(ValidationFailure(e.message));
    } catch (e) {
      return Left(UnknownFailure(e.toString()));
    }
  }
}
